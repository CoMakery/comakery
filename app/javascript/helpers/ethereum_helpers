/** Converts functionSignature to hexadecimal string */
export function functionSignatureToHex(functionSignature: string): string {
  const web3 = new Web3()
  return web3.eth.abi.encodeFunctionSignature(functionSignature)
}

export function isNullOrEmpty(obj: any): boolean {
  if (obj === undefined) {
    return true
  }
  if (obj === null) {
    return true
  }

  if (isAUint8Array(obj)) {
    return obj.length === 0
  }

  if (isABuffer(obj)) {
    return obj.byteLength === 0
  }

  // Check for an empty array too
  // eslint-disable-next-line no-prototype-builtins
  if (obj.hasOwnProperty('length')) {
    if (obj.length === 0) {
      return true
    }
  }
  return Object.keys(obj).length === 0 && obj.constructor === Object
}

export function isAString(value: any) {
  if (!value) {
    return false
  }
  return typeof value === 'string' || value instanceof String
}

/** Checks that string starts with 0x - appends if not
 *  Also converts hex chars to lowercase for consistency
 */
 export function ensureHexPrefix(value: string) {
  if (!value) return value
  return value.startsWith('0x') ? value.toLowerCase() : `${'0x'}${value.toLowerCase()}`
}

export function isValidEthereumTxData(value: string | Buffer | EthereumTxData): value is EthereumTxData {
  if (isNullOrEmpty(value)) return false
  // return false for '0x' as well as empty string
  if (isAString(value)) return ensureHexPrefix(value as string).length > 2
  return true
}



/** Accepts hex string checks if a valid ethereum data hex
 *  Returns EthereumPublicKey with prefix
 */
export function toEthereumTxData(value: string | Buffer): EthereumTxData {
  if (isValidEthereumTxData(value)) {
    return isAString(value) ? (ensureHexPrefix(value) as EthereumTxData) : (value as EthereumTxData)
  }
  throw new Error(`Not valid ethereum transaction data:${JSON.stringify(value)}.`)
}



/** Generates hexadecimal string for transaction data from EthereumActionContract */
export function generateDataFromContractAction(contractAction: EthereumActionContract) {
  const { abi, method, parameters } = contractAction
  const web3 = new Web3()
  const contract = new web3.eth.Contract(abi)
  const methodHex = functionSignatureToHex(abiToFunctionSignature(method, abi))
  return toEthereumTxData(contract.methods[methodHex](...parameters).encodeABI())
}